<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>DRONE HUNTER</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="drone-hunt.png">
    <link rel="apple-touch-icon" href="drone-hunt.png">

    <!-- Open Graph / Social Media Preview -->
    <meta property="og:title" content="DRONE HUNTER">
    <meta property="og:description" content="Retro arcade drone shooter. Blast drones out of the sky before they reach you!">
    <meta property="og:image" content="https://patrickjrobinson.github.io/games/drone-hunt/drone-hunt.png">
    <meta property="og:url" content="https://patrickjrobinson.github.io/games/drone-hunt/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="DRONE HUNTER">
    <meta name="twitter:description" content="Retro arcade drone shooter. Blast drones out of the sky before they reach you!">
    <meta name="twitter:image" content="https://patrickjrobinson.github.io/games/drone-hunt/drone-hunt.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            touch-action: none;
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #startScreen h1 {
                font-size: 28px !important;
            }
            .subtitle {
                font-size: 10px !important;
            }
            .instructions {
                font-size: 8px !important;
                padding: 0 20px;
            }
            .btn {
                padding: 12px 30px !important;
                font-size: 12px !important;
            }
            .ui-box {
                padding: 5px 8px !important;
                border-width: 1px !important;
                background: rgba(0, 0, 0, 0.5) !important;
                box-shadow: none !important;
            }
            .ui-label {
                font-size: 6px !important;
                margin-bottom: 2px !important;
            }
            .ui-value {
                font-size: 12px !important;
            }
            #ui {
                padding: 8px 10px !important;
            }
            .life-icon {
                width: 20px !important;
                height: 20px !important;
            }
            #lives-container {
                bottom: 12px !important;
                gap: 10px !important;
            }
            #gameOverScreen h2 {
                font-size: 24px !important;
            }
            #finalScore {
                font-size: 18px !important;
            }
            #waveReached {
                font-size: 12px !important;
            }
            #waveAnnounce .wave-text {
                font-size: 32px !important;
            }
            #waveAnnounce .ready-text {
                font-size: 14px !important;
            }
            #powerupBar {
                width: 120px !important;
                height: 12px !important;
                bottom: 50px !important;
            }
            #powerupLabel {
                font-size: 7px !important;
                bottom: 68px !important;
            }
        }

        /* CRT Scanline Overlay */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 100;
        }

        /* UI Overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 50;
        }

        .ui-box {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0ff;
            padding: 10px 20px;
            box-shadow: 0 0 10px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .ui-label {
            color: #0ff;
            font-size: 10px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #0ff;
        }

        .ui-value {
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 10px #fff;
        }

        #lives-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 50;
        }

        .life-icon {
            width: 30px;
            height: 30px;
            border: 2px solid #f0f;
            border-radius: 50%;
            background: radial-gradient(circle, #f0f 0%, transparent 70%);
            box-shadow: 0 0 15px #f0f;
            transition: opacity 0.3s;
        }

        .life-icon.lost {
            opacity: 0.2;
            box-shadow: none;
        }

        /* Power-up indicator */
        #powerupBar {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #f00;
            z-index: 50;
            display: none;
        }

        #powerupFill {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0);
            box-shadow: 0 0 10px #f00;
            transition: width 0.1s;
        }

        #powerupLabel {
            position: fixed;
            bottom: 95px;
            left: 50%;
            transform: translateX(-50%);
            color: #f00;
            font-size: 10px;
            text-shadow: 0 0 10px #f00;
            z-index: 50;
            display: none;
        }

        /* Screens */
        .screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 75;
        }

        .screen-overlay.hidden {
            display: none;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 30px #0ff, 0 0 60px #0ff; }
            to { text-shadow: 0 0 40px #0ff, 0 0 80px #0ff, 0 0 100px #0ff; }
        }

        .subtitle {
            color: #f0f;
            font-size: 12px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #f0f;
        }

        .instructions {
            color: #888;
            font-size: 10px;
            margin-bottom: 30px;
            text-align: center;
            line-height: 2;
        }

        .btn {
            background: transparent;
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px 40px;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            cursor: pointer;
            text-shadow: 0 0 10px #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            transition: all 0.2s;
        }

        .btn:hover {
            background: #0f0;
            color: #000;
            text-shadow: none;
            box-shadow: 0 0 40px #0f0;
        }

        #gameOverScreen h2 {
            font-size: 36px;
            color: #f00;
            text-shadow: 0 0 30px #f00;
            margin-bottom: 20px;
        }

        #finalScore {
            color: #ff0;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0;
        }

        #waveReached {
            color: #0ff;
            font-size: 14px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #0ff;
        }

        /* Wave Announcement */
        #waveAnnounce {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 60;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #waveAnnounce.visible {
            opacity: 1;
        }

        #waveAnnounce .wave-text {
            font-size: 48px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff;
        }

        #waveAnnounce .ready-text {
            font-size: 18px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-top: 10px;
        }

        #waveAnnounce .wave-message {
            font-size: 24px;
            color: #0f0;
            text-shadow: 0 0 20px #0f0, 0 0 40px #0f0;
            margin-bottom: 20px;
            animation: messagePulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes messagePulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        /* Weapon indicator */
        #weaponIndicator {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 50;
            pointer-events: none;
        }

        #weaponName {
            color: #0f0;
            font-size: 12px;
            text-shadow: 0 0 10px currentColor;
            margin-bottom: 5px;
        }

        #weaponAmmo {
            color: #ff0;
            font-size: 10px;
            text-shadow: 0 0 8px #ff0;
        }

        @media (max-width: 768px) {
            #waveAnnounce .wave-message {
                font-size: 16px !important;
            }
            #weaponIndicator {
                bottom: 85px !important;
            }
            #weaponName {
                font-size: 9px !important;
            }
            #weaponAmmo {
                font-size: 8px !important;
            }
        }

        /* Fullscreen button - map widget style */
        #fullscreenBtn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            z-index: 90;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        #fullscreenBtn:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.95);
        }

        #fullscreenBtn:active {
            transform: scale(0.95);
        }

        #fullscreenBtn svg {
            pointer-events: none;
        }

        /* Pause button - same style as fullscreen */
        #pauseBtn {
            position: fixed;
            bottom: 15px;
            right: 55px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            z-index: 90;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        #pauseBtn:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.95);
        }

        #pauseBtn:active {
            transform: scale(0.95);
        }

        #pauseBtn svg {
            pointer-events: none;
        }

        /* Pause overlay */
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 80;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }

        #pauseOverlay.visible {
            display: flex;
        }

        #pauseText {
            color: #0ff;
            font-size: 36px;
            text-shadow: 0 0 20px #0ff;
            animation: pausePulse 1.5s ease-in-out infinite;
        }

        @keyframes pausePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 768px) {
            #fullscreenBtn {
                bottom: 10px;
                right: 10px;
                width: 28px;
                height: 28px;
            }
            #fullscreenBtn svg {
                width: 14px;
                height: 14px;
            }
            #pauseBtn {
                bottom: 10px;
                right: 45px;
                width: 28px;
                height: 28px;
            }
            #pauseBtn svg {
                width: 14px;
                height: 14px;
            }
            #pauseText {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="scanlines"></div>

    <!-- Fullscreen toggle button -->
    <button id="fullscreenBtn" title="Toggle fullscreen">
        <svg id="fsExpand" viewBox="0 0 24 24" width="18" height="18">
            <path fill="currentColor" d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
        </svg>
        <svg id="fsCollapse" viewBox="0 0 24 24" width="18" height="18" style="display:none;">
            <path fill="currentColor" d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
        </svg>
    </button>

    <!-- Pause button -->
    <button id="pauseBtn" title="Pause game" style="display:none;">
        <svg id="pauseIcon" viewBox="0 0 24 24" width="18" height="18">
            <path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
        <svg id="playIcon" viewBox="0 0 24 24" width="18" height="18" style="display:none;">
            <path fill="currentColor" d="M8 5v14l11-7z"/>
        </svg>
    </button>

    <!-- Pause overlay -->
    <div id="pauseOverlay">
        <div id="pauseText">PAUSED</div>
    </div>

    <div id="ui">
        <div class="ui-box">
            <div class="ui-label">SCORE</div>
            <div class="ui-value" id="scoreDisplay">0</div>
        </div>
        <div class="ui-box">
            <div class="ui-label">WAVE</div>
            <div class="ui-value" id="waveDisplay">1</div>
        </div>
    </div>

    <div id="lives-container">
        <div class="life-icon" id="life1"></div>
        <div class="life-icon" id="life2"></div>
        <div class="life-icon" id="life3"></div>
    </div>

    <div id="powerupLabel">LASER ACTIVE</div>
    <div id="powerupBar"><div id="powerupFill"></div></div>

    <div id="waveAnnounce">
        <div id="waveMessage" class="wave-message"></div>
        <div class="wave-text">WAVE <span id="announceWaveNum">1</span></div>
        <div class="ready-text">GET READY</div>
    </div>

    <div id="weaponIndicator">
        <div id="weaponName">SHOTGUN</div>
        <div id="weaponAmmo"></div>
    </div>

    <div id="startScreen" class="screen-overlay">
        <h1>DRONE HUNTER</h1>
        <p class="subtitle">ARCADE EDITION</p>
        <div class="instructions">
            TAP OR CLICK TO SHOOT<br>
            DESTROY DRONES BEFORE THEY REACH YOU<br>
            SHOOT RABBITS FOR LASER POWER-UP<br>
            SHOOT ALIENS TO STEAL THEIR WEAPONS<br>
            SURVIVE THE WAVES
        </div>
        <button class="btn" id="startBtn">START GAME</button>
    </div>

    <div id="gameOverScreen" class="screen-overlay hidden">
        <h2>GAME OVER</h2>
        <div id="finalScore">SCORE: 0</div>
        <div id="waveReached">WAVE 1</div>
        <button class="btn" id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        // ============ AUDIO SYSTEM ============
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicGain = null;
        let musicOscillators = [];

        // Chill arcade background music
        function startMusic() {
            if (musicPlaying) return;
            musicPlaying = true;

            // Master gain for music
            musicGain = audioCtx.createGain();
            musicGain.gain.value = 0.12; // Keep it subtle
            musicGain.connect(audioCtx.destination);

            // Create a filter for warmth
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1200;
            filter.connect(musicGain);

            // Bass line pattern (classic arcade vibe)
            const bassNotes = [55, 55, 73.4, 55, 82.4, 73.4, 55, 55]; // A1, D2, E2 pattern
            let bassIndex = 0;

            function playBass() {
                if (!musicPlaying) return;

                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = bassNotes[bassIndex];

                const gain = audioCtx.createGain();
                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);

                osc.connect(gain);
                gain.connect(filter);
                osc.start(now);
                osc.stop(now + 0.4);

                bassIndex = (bassIndex + 1) % bassNotes.length;
                setTimeout(playBass, 400);
            }

            // Pad/chord layer (dreamy synth)
            function playPad() {
                if (!musicPlaying) return;

                const chords = [
                    [220, 277.2, 329.6],  // Am
                    [196, 246.9, 293.7],  // G
                    [174.6, 220, 261.6],  // F
                    [196, 246.9, 293.7],  // G
                ];
                const chordIndex = Math.floor(Date.now() / 3200) % chords.length;

                chords[chordIndex].forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const gain = audioCtx.createGain();
                    const now = audioCtx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.5);
                    gain.gain.linearRampToValueAtTime(0.06, now + 2.5);
                    gain.gain.linearRampToValueAtTime(0, now + 3.2);

                    osc.connect(gain);
                    gain.connect(filter);
                    osc.start(now);
                    osc.stop(now + 3.2);
                });

                setTimeout(playPad, 3200);
            }

            // Arpeggio melody (classic arcade feel)
            const arpeggioNotes = [440, 523, 659, 523, 440, 392, 440, 523];
            let arpIndex = 0;

            function playArpeggio() {
                if (!musicPlaying) return;

                if (Math.random() > 0.3) { // Don't play every time for variation
                    const osc = audioCtx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.value = arpeggioNotes[arpIndex];

                    const gain = audioCtx.createGain();
                    const now = audioCtx.currentTime;
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                    osc.connect(gain);
                    gain.connect(filter);
                    osc.start(now);
                    osc.stop(now + 0.2);
                }

                arpIndex = (arpIndex + 1) % arpeggioNotes.length;
                setTimeout(playArpeggio, 200);
            }

            // Start all layers
            playBass();
            setTimeout(playPad, 100);
            setTimeout(playArpeggio, 800);
        }

        function stopMusic() {
            musicPlaying = false;
            if (musicGain) {
                musicGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            }
        }

        function playSound(type) {
            const now = audioCtx.currentTime;

            if (type === 'shotgun') {
                // Shotgun blast - loud low-frequency burst
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                }
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, now + 0.3);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.25);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(now);
                noise.stop(now + 0.3);

                // Add a click/punch
                const osc = audioCtx.createOscillator();
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                const oscGain = audioCtx.createGain();
                oscGain.gain.setValueAtTime(0.5, now);
                oscGain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.connect(oscGain);
                oscGain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            }

            if (type === 'reload') {
                // Pump action reload sound
                setTimeout(() => {
                    const now2 = audioCtx.currentTime;

                    // First click (pump back)
                    const click1 = audioCtx.createOscillator();
                    click1.frequency.value = 200;
                    const click1Gain = audioCtx.createGain();
                    click1Gain.gain.setValueAtTime(0.3, now2);
                    click1Gain.gain.linearRampToValueAtTime(0, now2 + 0.05);
                    click1.connect(click1Gain);
                    click1Gain.connect(audioCtx.destination);
                    click1.start(now2);
                    click1.stop(now2 + 0.05);

                    // Slide noise
                    const noise = audioCtx.createBufferSource();
                    const bufferSize = audioCtx.sampleRate * 0.15;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.2;
                    }
                    noise.buffer = buffer;
                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = 2000;
                    const noiseGain = audioCtx.createGain();
                    noiseGain.gain.value = 0.15;
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(audioCtx.destination);
                    noise.start(now2 + 0.05);
                    noise.stop(now2 + 0.2);

                    // Second click (pump forward)
                    const click2 = audioCtx.createOscillator();
                    click2.frequency.value = 300;
                    const click2Gain = audioCtx.createGain();
                    click2Gain.gain.setValueAtTime(0.4, now2 + 0.2);
                    click2Gain.gain.linearRampToValueAtTime(0, now2 + 0.25);
                    click2.connect(click2Gain);
                    click2Gain.connect(audioCtx.destination);
                    click2.start(now2 + 0.2);
                    click2.stop(now2 + 0.25);
                }, 200);
            }

            if (type === 'droneScream') {
                // Pathetic drone scream "ahhh"
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();

                osc1.type = 'sawtooth';
                osc2.type = 'square';

                // Start high, go down (falling scream)
                osc1.frequency.setValueAtTime(800, now);
                osc1.frequency.linearRampToValueAtTime(200, now + 0.4);
                osc2.frequency.setValueAtTime(820, now);
                osc2.frequency.linearRampToValueAtTime(180, now + 0.4);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 2;

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 0.4);
                osc2.stop(now + 0.4);
            }

            if (type === 'laser') {
                // Laser zap sound
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            }

            if (type === 'powerup') {
                // Power-up collected sound
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0.15, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.15);
                });
            }

            if (type === 'loseLife') {
                // Painful hit sound - low thud with alarm
                const thud = audioCtx.createOscillator();
                thud.type = 'sine';
                thud.frequency.setValueAtTime(80, now);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                const thudGain = audioCtx.createGain();
                thudGain.gain.setValueAtTime(0.5, now);
                thudGain.gain.linearRampToValueAtTime(0, now + 0.3);
                thud.connect(thudGain);
                thudGain.connect(audioCtx.destination);
                thud.start(now);
                thud.stop(now + 0.3);

                // Warning beep
                const beep = audioCtx.createOscillator();
                beep.type = 'square';
                beep.frequency.value = 220;
                const beepGain = audioCtx.createGain();
                beepGain.gain.setValueAtTime(0.2, now);
                beepGain.gain.linearRampToValueAtTime(0, now + 0.1);
                beep.connect(beepGain);
                beepGain.connect(audioCtx.destination);
                beep.start(now);
                beep.stop(now + 0.1);

                // Second beep
                const beep2 = audioCtx.createOscillator();
                beep2.type = 'square';
                beep2.frequency.value = 180;
                const beep2Gain = audioCtx.createGain();
                beep2Gain.gain.setValueAtTime(0.2, now + 0.15);
                beep2Gain.gain.linearRampToValueAtTime(0, now + 0.25);
                beep2.connect(beep2Gain);
                beep2Gain.connect(audioCtx.destination);
                beep2.start(now + 0.15);
                beep2.stop(now + 0.25);
            }

            if (type === 'gameOver') {
                // Dramatic game over sound - descending doom
                const notes = [392, 349, 294, 220, 147]; // G4 down to D3
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 600;

                    const gain = audioCtx.createGain();
                    const startTime = now + i * 0.2;
                    gain.gain.setValueAtTime(0.25, startTime);
                    gain.gain.linearRampToValueAtTime(0.15, startTime + 0.15);
                    gain.gain.linearRampToValueAtTime(0, startTime + 0.25);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });

                // Final low boom
                const boom = audioCtx.createOscillator();
                boom.type = 'sine';
                boom.frequency.setValueAtTime(60, now + 1);
                boom.frequency.exponentialRampToValueAtTime(30, now + 1.5);
                const boomGain = audioCtx.createGain();
                boomGain.gain.setValueAtTime(0.4, now + 1);
                boomGain.gain.linearRampToValueAtTime(0, now + 1.5);
                boom.connect(boomGain);
                boomGain.connect(audioCtx.destination);
                boom.start(now + 1);
                boom.stop(now + 1.5);
            }

            if (type === 'ak47') {
                // AK-47 rapid fire burst
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.05));
                }
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1500;

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.1);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(now);
                noise.stop(now + 0.1);

                // Metallic click
                const click = audioCtx.createOscillator();
                click.frequency.value = 400;
                const clickGain = audioCtx.createGain();
                clickGain.gain.setValueAtTime(0.3, now);
                clickGain.gain.linearRampToValueAtTime(0, now + 0.02);
                click.connect(clickGain);
                clickGain.connect(audioCtx.destination);
                click.start(now);
                click.stop(now + 0.02);
            }

            if (type === 'bazooka') {
                // Bazooka rocket launch - whoosh then boom
                const whoosh = audioCtx.createOscillator();
                whoosh.type = 'sawtooth';
                whoosh.frequency.setValueAtTime(100, now);
                whoosh.frequency.exponentialRampToValueAtTime(400, now + 0.3);

                const whooshGain = audioCtx.createGain();
                whooshGain.gain.setValueAtTime(0.3, now);
                whooshGain.gain.linearRampToValueAtTime(0, now + 0.3);

                whoosh.connect(whooshGain);
                whooshGain.connect(audioCtx.destination);
                whoosh.start(now);
                whoosh.stop(now + 0.3);

                // Explosion
                setTimeout(() => {
                    const now2 = audioCtx.currentTime;
                    const noise = audioCtx.createBufferSource();
                    const bufferSize = audioCtx.sampleRate * 0.5;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
                    }
                    noise.buffer = buffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500;

                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0.8, now2);
                    gain.gain.linearRampToValueAtTime(0, now2 + 0.5);

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    noise.start(now2);
                    noise.stop(now2 + 0.5);
                }, 150);
            }

            if (type === 'railgun') {
                // Railgun charge and release
                const charge = audioCtx.createOscillator();
                charge.type = 'sine';
                charge.frequency.setValueAtTime(200, now);
                charge.frequency.exponentialRampToValueAtTime(2000, now + 0.15);

                const chargeGain = audioCtx.createGain();
                chargeGain.gain.setValueAtTime(0.1, now);
                chargeGain.gain.linearRampToValueAtTime(0.4, now + 0.15);
                chargeGain.gain.linearRampToValueAtTime(0, now + 0.2);

                charge.connect(chargeGain);
                chargeGain.connect(audioCtx.destination);
                charge.start(now);
                charge.stop(now + 0.2);

                // Electric zap
                const zap = audioCtx.createOscillator();
                zap.type = 'sawtooth';
                zap.frequency.setValueAtTime(3000, now + 0.15);
                zap.frequency.exponentialRampToValueAtTime(50, now + 0.3);

                const zapGain = audioCtx.createGain();
                zapGain.gain.setValueAtTime(0.5, now + 0.15);
                zapGain.gain.linearRampToValueAtTime(0, now + 0.3);

                zap.connect(zapGain);
                zapGain.connect(audioCtx.destination);
                zap.start(now + 0.15);
                zap.stop(now + 0.3);
            }

            if (type === 'alienScream') {
                // Alien death scream - weird and otherworldly
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();

                osc1.type = 'sine';
                osc2.type = 'triangle';

                osc1.frequency.setValueAtTime(1200, now);
                osc1.frequency.linearRampToValueAtTime(400, now + 0.3);
                osc2.frequency.setValueAtTime(1250, now);
                osc2.frequency.linearRampToValueAtTime(300, now + 0.35);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.35);

                // Add vibrato for alien effect
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 30;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 50;
                lfo.connect(lfoGain);
                lfoGain.connect(osc1.frequency);
                lfoGain.connect(osc2.frequency);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(audioCtx.destination);

                lfo.start(now);
                osc1.start(now);
                osc2.start(now);
                lfo.stop(now + 0.35);
                osc1.stop(now + 0.35);
                osc2.stop(now + 0.35);
            }

            if (type === 'weaponPickup') {
                // Weapon pickup - triumphant ascending notes
                const notes = [392, 523, 659, 784]; // G4, C5, E5, G5
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0.2, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.08 + 0.12);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.15);
                });
            }
        }

        // ============ GAME SETUP ============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============ STARS (Random positions) ============
        let stars = [];
        let trees = [];
        function generateStars() {
            stars = [];
            trees = [];
            const horizonY = canvas.height * 0.5;
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * horizonY * 0.8,
                    size: 0.5 + Math.random() * 2,
                    twinkle: Math.random() * Math.PI * 2,
                    twinkleSpeed: 0.02 + Math.random() * 0.03
                });
            }
            // Generate static trees
            for (let x = 0; x < canvas.width + 40; x += 25 + Math.random() * 15) {
                trees.push({
                    x: x,
                    height: 40 + Math.sin(x * 0.02) * 20 + Math.random() * 30,
                    width: 15 + Math.random() * 10
                });
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateStars();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        // ============ GAME STATE ============
        let gameState = 'start';
        let isPaused = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let drones = [];
        let explosions = [];
        let animals = [];
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let screenShake = 0;
        let waveIntroTimer = 0;
        let dronesRemaining = 0;
        let dronesSpawned = 0;
        let spawnTimer = 0;
        let animalSpawnTimer = 0;

        // Laser power-up state
        let laserActive = false;
        let laserTimeRemaining = 0;
        const LASER_DURATION = 30;

        // Weapon system
        const WEAPONS = {
            shotgun: {
                name: 'SHOTGUN',
                color: '#0f0',
                ammo: Infinity,
                sound: 'shotgun',
                spread: true
            },
            laser: {
                name: 'LASER RIFLE',
                color: '#f00',
                ammo: 50,
                sound: 'laser',
                beam: true
            },
            ak47: {
                name: 'AK-47',
                color: '#ff0',
                ammo: 30,
                sound: 'ak47',
                rapid: true
            },
            bazooka: {
                name: 'BAZOOKA',
                color: '#f80',
                ammo: 5,
                sound: 'bazooka',
                explosive: true
            },
            railgun: {
                name: 'RAILGUN',
                color: '#0ff',
                ammo: 10,
                sound: 'railgun',
                pierce: true
            }
        };

        let currentWeapon = 'shotgun';
        let weaponAmmo = {};
        let aliens = [];
        let alienSpawnTimer = 0;

        // Encouraging messages for wave completion
        const WAVE_MESSAGES = [
            "FUCK YEAH!",
            "BRO, THAT WAS SICK!",
            "STEEZY!",
            "ABSOLUTELY GOATED!",
            "LET'S GOOO!",
            "DUDE, INSANE!",
            "YOU'RE CRACKED!",
            "SHEEEESH!",
            "BUILT DIFFERENT!",
            "NO CAP, FIRE!"
        ];

        // ============ ANIMAL CLASS ============
        class Animal {
            constructor(type) {
                this.type = type; // 'rabbit' or 'zebra'
                this.direction = Math.random() < 0.5 ? 1 : -1;
                this.x = this.direction === 1 ? -100 : canvas.width + 100;
                this.y = canvas.height * 0.7 + Math.random() * (canvas.height * 0.2);
                this.speed = type === 'rabbit' ? (3 + Math.random() * 2) : (1.5 + Math.random());
                this.frame = 0;
                this.frameTimer = 0;
                this.hit = false;
                this.size = type === 'rabbit' ? 30 : 60;
                this.hopOffset = 0;
                this.hopSpeed = type === 'rabbit' ? 0.3 : 0.1;
            }

            update(deltaTime) {
                if (this.hit) return true;

                this.x += this.speed * this.direction * deltaTime * 60;
                this.frameTimer += deltaTime;
                if (this.frameTimer > 0.1) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameTimer = 0;
                }

                // Hopping motion
                this.hopOffset = Math.abs(Math.sin(this.x * this.hopSpeed)) * (this.type === 'rabbit' ? 20 : 10);

                // Remove if off screen
                if (this.direction === 1 && this.x > canvas.width + 150) return true;
                if (this.direction === -1 && this.x < -150) return true;

                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y - this.hopOffset);
                if (this.direction === -1) ctx.scale(-1, 1);

                if (this.type === 'rabbit') {
                    // Cute rabbit silhouette
                    ctx.fillStyle = '#8B7355';

                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.6, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Head
                    ctx.beginPath();
                    ctx.arc(this.size * 0.5, -this.size * 0.2, this.size * 0.35, 0, Math.PI * 2);
                    ctx.fill();

                    // Ears
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.4, -this.size * 0.7, this.size * 0.1, this.size * 0.3, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.6, -this.size * 0.7, this.size * 0.1, this.size * 0.3, 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    // Tail
                    ctx.fillStyle = '#DDD';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.5, 0, this.size * 0.15, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.6, -this.size * 0.25, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Legs (animated)
                    ctx.fillStyle = '#8B7355';
                    const legOffset = Math.sin(this.frame * Math.PI / 2) * 5;
                    ctx.fillRect(-this.size * 0.3, this.size * 0.2, 8, 15 + legOffset);
                    ctx.fillRect(this.size * 0.1, this.size * 0.2, 8, 15 - legOffset);
                } else {
                    // Zebra
                    ctx.fillStyle = '#FFF';

                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Stripes
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    for (let i = -3; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * 12, -this.size * 0.35);
                        ctx.lineTo(i * 12 - 5, this.size * 0.35);
                        ctx.stroke();
                    }

                    // Neck
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.5, -this.size * 0.2);
                    ctx.lineTo(this.size * 0.7, -this.size * 0.8);
                    ctx.lineTo(this.size * 0.9, -this.size * 0.7);
                    ctx.lineTo(this.size * 0.7, -this.size * 0.1);
                    ctx.fill();

                    // Neck stripes
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.55, -this.size * 0.35);
                    ctx.lineTo(this.size * 0.75, -this.size * 0.45);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.6, -this.size * 0.5);
                    ctx.lineTo(this.size * 0.8, -this.size * 0.6);
                    ctx.stroke();

                    // Head
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.85, -this.size * 0.85, this.size * 0.25, this.size * 0.15, 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Mane
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.size * 0.55, -this.size * 0.9, this.size * 0.25, 8);

                    // Eye
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.9, -this.size * 0.85, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Legs
                    ctx.fillStyle = '#FFF';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    const legOffset = Math.sin(this.frame * Math.PI / 2) * 8;

                    // Front legs
                    ctx.fillRect(this.size * 0.3, this.size * 0.25, 8, 35 + legOffset);
                    ctx.strokeRect(this.size * 0.3, this.size * 0.25, 8, 35 + legOffset);
                    ctx.fillRect(this.size * 0.45, this.size * 0.25, 8, 35 - legOffset);
                    ctx.strokeRect(this.size * 0.45, this.size * 0.25, 8, 35 - legOffset);

                    // Back legs
                    ctx.fillRect(-this.size * 0.5, this.size * 0.25, 8, 35 - legOffset);
                    ctx.strokeRect(-this.size * 0.5, this.size * 0.25, 8, 35 - legOffset);
                    ctx.fillRect(-this.size * 0.35, this.size * 0.25, 8, 35 + legOffset);
                    ctx.strokeRect(-this.size * 0.35, this.size * 0.25, 8, 35 + legOffset);

                    // Tail
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.7, -this.size * 0.1);
                    ctx.quadraticCurveTo(-this.size * 0.9, this.size * 0.2, -this.size * 0.85, this.size * 0.4);
                    ctx.stroke();
                }

                ctx.restore();

                // Store hitbox
                this.screenX = this.x;
                this.screenY = this.y - this.hopOffset;
                this.hitRadius = this.size;
            }

            checkHit(x, y) {
                const dx = x - this.screenX;
                const dy = y - this.screenY;
                return Math.sqrt(dx * dx + dy * dy) < this.hitRadius;
            }
        }

        // ============ ALIEN CLASS ============
        class Alien {
            constructor() {
                this.direction = Math.random() < 0.5 ? 1 : -1;
                this.x = this.direction === 1 ? -100 : canvas.width + 100;
                this.y = 80 + Math.random() * (canvas.height * 0.3);
                this.speed = 2.5 + Math.random() * 2;
                this.hit = false;
                this.size = 45;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.screenX = this.x;
                this.screenY = this.y;
                this.hitRadius = this.size;

                // Random weapon that the alien carries (excluding shotgun which is default)
                const weaponTypes = ['laser', 'ak47', 'bazooka', 'railgun'];
                this.weapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                this.glowPhase = 0;
            }

            update(deltaTime) {
                if (this.hit) return true;

                this.x += this.speed * this.direction * deltaTime * 60;
                this.wobbleOffset += 0.05 * deltaTime * 60;
                this.y += Math.sin(this.wobbleOffset) * 0.8;
                this.glowPhase += 0.1 * deltaTime * 60;

                // Remove if off screen
                if (this.direction === 1 && this.x > canvas.width + 150) return true;
                if (this.direction === -1 && this.x < -150) return true;

                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const weaponColor = WEAPONS[this.weapon].color;
                const glowIntensity = 0.5 + Math.sin(this.glowPhase) * 0.3;

                // UFO glow
                ctx.shadowBlur = 25;
                ctx.shadowColor = weaponColor;

                // UFO dome (glass)
                ctx.fillStyle = `rgba(100, 200, 255, ${0.3 + glowIntensity * 0.2})`;
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.2, this.size * 0.35, this.size * 0.35, 0, Math.PI, 0);
                ctx.fill();

                // Alien inside dome
                ctx.fillStyle = '#3f3';
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.15, this.size * 0.15, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Alien eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.07, -this.size * 0.2, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.07, -this.size * 0.2, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // UFO body (metallic disc)
                const gradient = ctx.createLinearGradient(0, -this.size * 0.1, 0, this.size * 0.15);
                gradient.addColorStop(0, '#888');
                gradient.addColorStop(0.5, '#ddd');
                gradient.addColorStop(1, '#666');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // UFO rim lights
                ctx.fillStyle = weaponColor;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.glowPhase;
                    const lx = Math.cos(angle) * this.size * 0.65;
                    const ly = Math.sin(angle) * this.size * 0.12;
                    ctx.beginPath();
                    ctx.arc(lx, ly, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // UFO bottom (beam emitter)
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.15, this.size * 0.25, this.size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Weapon indicator on the side
                ctx.fillStyle = weaponColor;
                ctx.shadowBlur = 15;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(WEAPONS[this.weapon].name, 0, this.size * 0.5);

                ctx.restore();

                // Store hitbox
                this.screenX = this.x;
                this.screenY = this.y;
                this.hitRadius = this.size;
            }

            checkHit(x, y) {
                const dx = x - this.screenX;
                const dy = y - this.screenY;
                return Math.sqrt(dx * dx + dy * dy) < this.hitRadius;
            }
        }

        // ============ DRONE CLASS ============
        class Drone {
            constructor(wave) {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * (canvas.height * 0.35) + 50;
                this.z = 800 + Math.random() * 200;
                this.baseSpeed = 1.5 + (wave * 0.3) + Math.random() * 0.5;
                this.speed = this.baseSpeed;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.03 + Math.random() * 0.02;
                this.hit = false;
                this.warningFlash = 0;
                this.hue = Math.random() < 0.5 ? 180 : 300;
                this.rotorAngle = Math.random() * Math.PI * 2;
                this.screenX = this.x;
                this.screenY = this.y;
                this.hitRadius = 50;
            }

            update(deltaTime) {
                if (this.hit) return false;
                this.z -= this.speed * deltaTime * 60;
                this.wobbleOffset += this.wobbleSpeed * deltaTime * 60;
                this.x += Math.sin(this.wobbleOffset) * 1.5;
                this.y += Math.cos(this.wobbleOffset * 0.7) * 0.5;
                this.x = Math.max(50, Math.min(canvas.width - 50, this.x));
                this.rotorAngle += 0.3 * deltaTime * 60;
                if (this.z < 150) {
                    this.warningFlash += 0.2 * deltaTime * 60;
                }
                if (this.z <= 0) return true;
                return false;
            }

            draw() {
                const scale = Math.max(0.1, 1 - this.z / 1000);
                const size = 20 + scale * 60;
                const screenX = this.x;
                const screenY = this.y + (canvas.height * 0.45 - this.y) * scale * 0.5;

                ctx.save();
                ctx.translate(screenX, screenY);

                const glowIntensity = 0.5 + scale * 0.5;
                const baseColor = this.z < 150 && Math.sin(this.warningFlash * 10) > 0
                    ? 'hsl(0, 100%, 50%)'
                    : `hsl(${this.hue}, 100%, 50%)`;

                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = baseColor;
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 2 + scale * 2;

                for (let i = 0; i < 4; i++) {
                    const angle = this.rotorAngle + (i * Math.PI / 2);
                    const armLength = size * 0.6;
                    const ax = Math.cos(angle) * armLength;
                    const ay = Math.sin(angle) * armLength * 0.4;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(ax, ay);
                    ctx.stroke();

                    ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${0.3 * glowIntensity})`;
                    ctx.beginPath();
                    ctx.arc(ax, ay, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.arc(ax, ay, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = '#111';
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.25, size * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = baseColor;
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                this.screenX = screenX;
                this.screenY = screenY;
                this.hitRadius = size * 0.7;
            }

            checkHit(x, y) {
                if (this.screenX === undefined || this.hitRadius === undefined) return false;
                const dx = x - this.screenX;
                const dy = y - this.screenY;
                return Math.sqrt(dx * dx + dy * dy) < this.hitRadius;
            }
        }

        // ============ EXPLOSION CLASS ============
        class Explosion {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.hue = hue;
                this.particles = [];
                this.life = 1;

                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 8;
                    this.particles.push({
                        x: 0, y: 0,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 2 + Math.random() * 4,
                        hue: this.hue + (Math.random() - 0.5) * 40
                    });
                }
            }

            update(deltaTime) {
                this.life -= 0.02 * deltaTime * 60;
                this.particles.forEach(p => {
                    p.x += p.vx * deltaTime * 60;
                    p.y += p.vy * deltaTime * 60;
                    p.vy += 0.1 * deltaTime * 60;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                });
                return this.life <= 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = Math.max(0, this.life);

                this.particles.forEach(p => {
                    const radius = Math.max(0.1, p.size * this.life);
                    ctx.fillStyle = `hsl(${p.hue}, 100%, ${50 + this.life * 30}%)`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${p.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // ============ RENDERING ============
        function drawBackground() {
            const horizonY = canvas.height * 0.5;

            // Brighter sky gradient (golden hour)
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizonY);
            skyGradient.addColorStop(0, '#1a1a3a');
            skyGradient.addColorStop(0.2, '#2d2d5a');
            skyGradient.addColorStop(0.4, '#4a3a6a');
            skyGradient.addColorStop(0.6, '#7a4a6a');
            skyGradient.addColorStop(0.8, '#aa6050');
            skyGradient.addColorStop(1, '#dd8844');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, horizonY);

            // Twinkling stars
            stars.forEach(star => {
                star.twinkle += star.twinkleSpeed;
                const brightness = 0.4 + Math.sin(star.twinkle) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 240, ${brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Big bright moon with glow
            ctx.fillStyle = 'rgba(255, 250, 220, 0.15)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.12, 80, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 250, 230, 0.95)';
            ctx.shadowBlur = 50;
            ctx.shadowColor = 'rgba(255, 250, 200, 0.8)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.12, 45, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Epic far mountains (snow-capped)
            ctx.fillStyle = '#3a3a5a';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            for (let x = 0; x <= canvas.width; x += 80) {
                const height = 100 + Math.sin(x * 0.006) * 60 + Math.sin(x * 0.012 + 1) * 40;
                ctx.lineTo(x, horizonY - height);
            }
            ctx.lineTo(canvas.width, horizonY);
            ctx.fill();

            // Snow caps
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            for (let x = 0; x <= canvas.width; x += 80) {
                const height = 100 + Math.sin(x * 0.006) * 60 + Math.sin(x * 0.012 + 1) * 40;
                const snowHeight = height * 0.3;
                ctx.lineTo(x, horizonY - height);
                ctx.lineTo(x + 40, horizonY - height + snowHeight);
            }
            ctx.lineTo(canvas.width, horizonY);
            ctx.fill();

            // Mid mountains
            ctx.fillStyle = '#2d3d4a';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            for (let x = 0; x <= canvas.width; x += 50) {
                const height = 60 + Math.sin(x * 0.01 + 2) * 45 + Math.sin(x * 0.018) * 25;
                ctx.lineTo(x, horizonY - height);
            }
            ctx.lineTo(canvas.width, horizonY);
            ctx.fill();

            // Near hills with trees
            ctx.fillStyle = '#1d2d24';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            for (let x = 0; x <= canvas.width; x += 30) {
                const height = 30 + Math.sin(x * 0.015 + 3) * 25 + Math.sin(x * 0.03) * 15;
                ctx.lineTo(x, horizonY - height);
            }
            ctx.lineTo(canvas.width, horizonY);
            ctx.fill();

            // Pine tree forest silhouette (pre-generated for stability)
            ctx.fillStyle = '#0d1d14';
            const baseY = horizonY + 10;
            trees.forEach(tree => {
                ctx.beginPath();
                ctx.moveTo(tree.x, baseY);
                ctx.lineTo(tree.x + tree.width / 2, baseY - tree.height);
                ctx.lineTo(tree.x + tree.width, baseY);
                ctx.fill();
            });

            // Grassy savanna ground
            const groundGradient = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
            groundGradient.addColorStop(0, '#3d5a3d');
            groundGradient.addColorStop(0.2, '#2d4a2d');
            groundGradient.addColorStop(0.5, '#1d3a1d');
            groundGradient.addColorStop(1, '#0d2a0d');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

            // Grass texture
            ctx.strokeStyle = 'rgba(60, 90, 50, 0.4)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 15; i++) {
                const y = horizonY + (i / 15) * (canvas.height - horizonY) * 1.1;
                const waviness = Math.sin(Date.now() / 2000 + i) * 3;
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x < canvas.width; x += 50) {
                    ctx.lineTo(x + 25, y + waviness);
                    ctx.lineTo(x + 50, y);
                }
                ctx.stroke();
            }

            // Horizon glow
            const horizonGlow = ctx.createLinearGradient(0, horizonY - 40, 0, horizonY + 30);
            horizonGlow.addColorStop(0, 'transparent');
            horizonGlow.addColorStop(0.4, 'rgba(255, 150, 80, 0.25)');
            horizonGlow.addColorStop(0.6, 'rgba(255, 120, 60, 0.2)');
            horizonGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = horizonGlow;
            ctx.fillRect(0, horizonY - 40, canvas.width, 70);
        }

        function drawCrosshair() {
            ctx.save();
            ctx.translate(mouseX, mouseY);

            const weapon = WEAPONS[currentWeapon];
            const color = laserActive ? '#f00' : weapon.color;

            ctx.strokeStyle = color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.fillStyle = color;

            if (laserActive || currentWeapon === 'laser') {
                // Laser crosshair (circles)
                ctx.lineWidth = 3;
                const size = 30;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (currentWeapon === 'ak47') {
                // AK-47 crosshair (small, precise)
                ctx.lineWidth = 2;
                const size = 15;
                const gap = 5;
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(0, -gap);
                ctx.moveTo(0, gap);
                ctx.lineTo(0, size);
                ctx.moveTo(-size, 0);
                ctx.lineTo(-gap, 0);
                ctx.moveTo(gap, 0);
                ctx.lineTo(size, 0);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (currentWeapon === 'bazooka') {
                // Bazooka crosshair (large blast radius indicator)
                ctx.lineWidth = 3;
                const size = 50;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                // Explosion indicator lines
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 15, Math.sin(angle) * 15);
                    ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                    ctx.stroke();
                }
            } else if (currentWeapon === 'railgun') {
                // Railgun crosshair (tech/futuristic)
                ctx.lineWidth = 2;
                const size = 25;
                // Outer diamond
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(size, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size, 0);
                ctx.closePath();
                ctx.stroke();
                // Inner targeting
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                // Tech lines
                ctx.beginPath();
                ctx.moveTo(-size - 5, 0);
                ctx.lineTo(-size + 5, 0);
                ctx.moveTo(size - 5, 0);
                ctx.lineTo(size + 5, 0);
                ctx.moveTo(0, -size - 5);
                ctx.lineTo(0, -size + 5);
                ctx.moveTo(0, size - 5);
                ctx.lineTo(0, size + 5);
                ctx.stroke();
            } else {
                // Default shotgun crosshair
                ctx.lineWidth = 2;
                const size = 25;
                const gap = 8;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, -size - 10);
                ctx.lineTo(0, -gap);
                ctx.moveTo(0, gap);
                ctx.lineTo(0, size + 10);
                ctx.moveTo(-size - 10, 0);
                ctx.lineTo(-gap, 0);
                ctx.moveTo(gap, 0);
                ctx.lineTo(size + 10, 0);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawLaserBeam(fromX, fromY, toX, toY) {
            ctx.save();
            ctx.strokeStyle = '#f00';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#f00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.restore();
        }

        // ============ WAVE MANAGEMENT ============
        function getDronesForWave(waveNum) {
            return 3 + (waveNum * 2);
        }

        let waveMessage = '';

        function startWave(waveNum) {
            wave = waveNum;
            dronesRemaining = getDronesForWave(waveNum);
            dronesSpawned = 0;
            spawnTimer = 0;

            // Show encouraging message for waves after the first
            if (waveNum > 1) {
                waveMessage = WAVE_MESSAGES[Math.floor(Math.random() * WAVE_MESSAGES.length)];
            } else {
                waveMessage = '';
            }

            document.getElementById('waveMessage').textContent = waveMessage;
            document.getElementById('waveDisplay').textContent = waveNum;
            document.getElementById('announceWaveNum').textContent = waveNum;
            document.getElementById('waveAnnounce').classList.add('visible');
            waveIntroTimer = waveNum > 1 ? 2.5 : 2; // Extra time to see the message
            gameState = 'waveIntro';
        }

        function spawnAlien() {
            aliens.push(new Alien());
        }

        function updateWeaponUI() {
            const weapon = WEAPONS[currentWeapon];
            const nameEl = document.getElementById('weaponName');
            const ammoEl = document.getElementById('weaponAmmo');

            nameEl.textContent = weapon.name;
            nameEl.style.color = weapon.color;

            if (weapon.ammo === Infinity) {
                ammoEl.textContent = '';
            } else {
                const ammo = weaponAmmo[currentWeapon] || 0;
                ammoEl.textContent = `AMMO: ${ammo}`;
                if (ammo <= 0) {
                    ammoEl.style.color = '#f00';
                } else if (ammo <= 5) {
                    ammoEl.style.color = '#f80';
                } else {
                    ammoEl.style.color = '#ff0';
                }
            }
        }

        function spawnDrone() {
            if (dronesSpawned < getDronesForWave(wave)) {
                drones.push(new Drone(wave));
                dronesSpawned++;
            }
        }

        function spawnAnimal() {
            const type = Math.random() < 0.3 ? 'rabbit' : 'zebra';
            animals.push(new Animal(type));
        }

        function checkWaveComplete() {
            if (dronesSpawned >= getDronesForWave(wave) && drones.length === 0) {
                const bonus = 500 * wave;
                score += bonus;
                updateScore();
                startWave(wave + 1);
            }
        }

        // ============ GAME LOGIC ============
        function updateScore() {
            document.getElementById('scoreDisplay').textContent = score;
        }

        function updateLives() {
            for (let i = 1; i <= 3; i++) {
                const lifeEl = document.getElementById('life' + i);
                if (i > lives) {
                    lifeEl.classList.add('lost');
                } else {
                    lifeEl.classList.remove('lost');
                }
            }
        }

        function updatePowerupBar() {
            const bar = document.getElementById('powerupBar');
            const fill = document.getElementById('powerupFill');
            const label = document.getElementById('powerupLabel');

            if (laserActive) {
                bar.style.display = 'block';
                label.style.display = 'block';
                fill.style.width = (laserTimeRemaining / LASER_DURATION * 100) + '%';
            } else {
                bar.style.display = 'none';
                label.style.display = 'none';
            }
        }

        function activateLaser() {
            laserActive = true;
            laserTimeRemaining = LASER_DURATION;
            playSound('powerup');
        }

        function loseLife() {
            lives--;
            updateLives();
            screenShake = 0.5;
            playSound('loseLife');
            if (lives <= 0) gameOver();
        }

        function gameOver() {
            gameState = 'gameOver';
            isPaused = false;
            laserActive = false;
            stopMusic();
            playSound('gameOver');
            document.getElementById('finalScore').textContent = 'SCORE: ' + score;
            document.getElementById('waveReached').textContent = 'REACHED WAVE ' + wave;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('pauseOverlay').classList.remove('visible');
        }

        function startGame() {
            // Resume audio context if suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // Start background music
            startMusic();

            gameState = 'playing';
            isPaused = false;
            score = 0;
            lives = 3;
            drones = [];
            explosions = [];
            animals = [];
            aliens = [];
            laserActive = false;
            laserTimeRemaining = 0;
            alienSpawnTimer = 3; // First alien appears quickly

            // Reset weapon to default
            currentWeapon = 'shotgun';
            weaponAmmo = {};

            updateScore();
            updateLives();
            updatePowerupBar();
            updateWeaponUI();

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('pauseBtn').style.display = 'flex';
            document.getElementById('pauseOverlay').classList.remove('visible');
            updatePauseButton();

            startWave(1);
        }

        // ============ MAIN GAME LOOP ============
        let lastTime = performance.now();
        let laserBeams = [];

        function gameLoop(timestamp) {
            const deltaTime = isPaused ? 0 : Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;

            ctx.save();
            if (screenShake > 0 && !isPaused) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 20,
                    (Math.random() - 0.5) * screenShake * 20
                );
                screenShake -= deltaTime * 2;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            if (gameState === 'waveIntro' && !isPaused) {
                waveIntroTimer -= deltaTime;
                if (waveIntroTimer <= 0) {
                    document.getElementById('waveAnnounce').classList.remove('visible');
                    gameState = 'playing';
                }
            }

            if (gameState === 'playing' && !isPaused) {
                // Laser timer
                if (laserActive) {
                    laserTimeRemaining -= deltaTime;
                    if (laserTimeRemaining <= 0) {
                        laserActive = false;
                    }
                    updatePowerupBar();
                }

                // Spawn drones
                spawnTimer -= deltaTime;
                if (spawnTimer <= 0 && dronesSpawned < getDronesForWave(wave)) {
                    spawnDrone();
                    spawnTimer = Math.max(0.5, 2 - wave * 0.1);
                }

                // Spawn animals regularly
                animalSpawnTimer -= deltaTime;
                if (animalSpawnTimer <= 0) {
                    spawnAnimal();
                    animalSpawnTimer = 4 + Math.random() * 4; // Every 4-8 seconds
                }

                // Spawn aliens regularly (more frequent in higher waves)
                alienSpawnTimer -= deltaTime;
                if (alienSpawnTimer <= 0) {
                    spawnAlien();
                    alienSpawnTimer = Math.max(3, 10 - wave) + Math.random() * 5; // Faster in higher waves
                }

                // Update aliens
                aliens = aliens.filter(alien => {
                    return !alien.update(deltaTime);
                });

                // Update drones
                drones = drones.filter(drone => {
                    const reached = drone.update(deltaTime);
                    if (reached) {
                        loseLife();
                        return false;
                    }
                    return !drone.hit;
                });

                // Update animals
                animals = animals.filter(animal => {
                    return !animal.update(deltaTime);
                });

                checkWaveComplete();
            }

            // Draw animals (behind drones)
            animals.forEach(animal => animal.draw());

            // Draw aliens (UFOs flying through)
            aliens.forEach(alien => alien.draw());

            // Draw drones
            [...drones].sort((a, b) => b.z - a.z).forEach(drone => drone.draw());

            // Draw laser beams
            laserBeams = laserBeams.filter(beam => {
                beam.life -= deltaTime * 5;
                if (beam.life > 0) {
                    ctx.globalAlpha = beam.life;
                    drawLaserBeam(beam.fromX, beam.fromY, beam.toX, beam.toY);
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            // Draw explosions
            explosions = explosions.filter(exp => {
                const done = exp.update(deltaTime);
                exp.draw();
                return !done;
            });

            drawCrosshair();
            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // ============ INPUT HANDLING ============
        let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Touch events for mobile
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            handleShoot(touch.clientX, touch.clientY);
        }, { passive: false });

        // Prevent scrolling on mobile
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        function handleShoot(clickX, clickY) {
            if (gameState !== 'playing' || isPaused) return;

            const weapon = WEAPONS[currentWeapon];

            // Check ammo for non-shotgun weapons
            if (weapon.ammo !== Infinity) {
                if (!weaponAmmo[currentWeapon] || weaponAmmo[currentWeapon] <= 0) {
                    // Out of ammo, switch back to shotgun
                    currentWeapon = 'shotgun';
                    updateWeaponUI();
                    playSound('shotgun');
                    playSound('reload');
                } else {
                    weaponAmmo[currentWeapon]--;
                    playSound(weapon.sound);
                    updateWeaponUI();
                }
            } else {
                playSound(weapon.sound);
                if (currentWeapon === 'shotgun') playSound('reload');
            }

            // Check alien hits first (highest priority - gives weapons!)
            for (let i = aliens.length - 1; i >= 0; i--) {
                if (aliens[i].checkHit(clickX, clickY)) {
                    const alien = aliens[i];
                    alien.hit = true;

                    // Player gets the alien's weapon!
                    currentWeapon = alien.weapon;
                    weaponAmmo[alien.weapon] = WEAPONS[alien.weapon].ammo;
                    updateWeaponUI();
                    playSound('weaponPickup');
                    playSound('alienScream');

                    // Create explosion
                    explosions.push(new Explosion(alien.screenX, alien.screenY, 120));
                    score += 200;
                    updateScore();
                    screenShake = 0.2;

                    aliens.splice(i, 1);
                    return; // Don't shoot through to other targets
                }
            }

            // Check animal hits
            for (let i = animals.length - 1; i >= 0; i--) {
                if (animals[i].checkHit(clickX, clickY)) {
                    if (animals[i].type === 'rabbit') {
                        // Rabbit gives laser power-up!
                        activateLaser();
                        animals[i].hit = true;
                        animals.splice(i, 1);
                        score += 50;
                        updateScore();
                    }
                    // Zebras are just distractions, can't shoot them
                    break;
                }
            }

            // Check drone hits
            const sortedDrones = [...drones].sort((a, b) => a.z - b.z);
            let hitCount = 0;
            const maxHits = weapon.pierce ? 3 : 1; // Railgun pierces through multiple drones
            const explosiveRadius = weapon.explosive ? 100 : 0; // Bazooka has splash damage

            for (const drone of sortedDrones) {
                if (hitCount >= maxHits) break;

                let isHit = drone.checkHit(clickX, clickY);

                // Bazooka splash damage
                if (!isHit && explosiveRadius > 0) {
                    const dx = clickX - drone.screenX;
                    const dy = clickY - drone.screenY;
                    if (Math.sqrt(dx * dx + dy * dy) < explosiveRadius) {
                        isHit = true;
                    }
                }

                if (isHit) {
                    drone.hit = true;
                    explosions.push(new Explosion(drone.screenX, drone.screenY, drone.hue));
                    playSound('droneScream');
                    score += 100;
                    updateScore();
                    screenShake = weapon.explosive ? 0.4 : 0.15;
                    hitCount++;

                    // Visual effects for special weapons
                    if (weapon.beam || laserActive) {
                        laserBeams.push({
                            fromX: clickX,
                            fromY: canvas.height,
                            toX: drone.screenX,
                            toY: drone.screenY,
                            life: 1
                        });
                    }
                }
            }

            // Bazooka creates big explosion effect even on miss
            if (weapon.explosive) {
                explosions.push(new Explosion(clickX, clickY, 30));
            }
        }

        canvas.addEventListener('click', (e) => {
            handleShoot(e.clientX, e.clientY);
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Prevent default touch behaviors
        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());

        // Fullscreen toggle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fsExpand = document.getElementById('fsExpand');
        const fsCollapse = document.getElementById('fsCollapse');

        function updateFullscreenButton() {
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            fsExpand.style.display = isFullscreen ? 'none' : 'block';
            fsCollapse.style.display = isFullscreen ? 'block' : 'none';
        }

        fullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            } else {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                }
            }
        });

        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);

        // Pause functionality
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseIcon = document.getElementById('pauseIcon');
        const playIcon = document.getElementById('playIcon');
        const pauseOverlay = document.getElementById('pauseOverlay');

        function updatePauseButton() {
            pauseIcon.style.display = isPaused ? 'none' : 'block';
            playIcon.style.display = isPaused ? 'block' : 'none';
        }

        function togglePause() {
            if (gameState !== 'playing' && gameState !== 'waveIntro') return;

            isPaused = !isPaused;
            updatePauseButton();

            if (isPaused) {
                pauseOverlay.classList.add('visible');
            } else {
                pauseOverlay.classList.remove('visible');
                lastTime = performance.now(); // Reset time to prevent jump
            }
        }

        pauseBtn.addEventListener('click', togglePause);

        // Keyboard pause (Escape or P)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                if (gameState === 'playing' || gameState === 'waveIntro') {
                    togglePause();
                }
            }
        });

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
